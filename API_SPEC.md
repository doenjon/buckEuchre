# API Specification

## Overview

This document defines all REST API endpoints and WebSocket events for the Buck Euchre application.

## Architecture

- **REST API**: Used for authentication, game creation, and queries
- **WebSocket**: Used for real-time game state updates and player actions
- **Port**: Backend runs on port 3000 (configurable)
- **Base URL**: `http://localhost:3000/api` (development)

## Authentication (Simplified for MVP)

### Approach: Name-Only Authentication
For MVP simplicity, players only provide a display name. No passwords, no persistent accounts.

```typescript
interface AuthResponse {
  playerId: string;    // UUID generated by server
  playerName: string;
  token: string;       // JWT token for this session
  expiresAt: number;   // Unix timestamp
}
```

## REST API Endpoints

### Health Check

```
GET /health

Response 200:
{
  "status": "ok",
  "timestamp": 1234567890
}
```

### Authentication

#### Create Session
```
POST /api/auth/join

Request Body:
{
  "playerName": string  // 2-20 characters
}

Response 201:
{
  "playerId": "uuid",
  "playerName": "John",
  "token": "jwt_token_here",
  "expiresAt": 1234567890
}

Errors:
400 - Invalid player name
500 - Server error
```

### Game Management

#### Create Game
```
POST /api/games

Headers:
  Authorization: Bearer <token>

Request Body:
{
  "name"?: string  // Optional game name
}

Response 201:
{
  "gameId": "uuid",
  "createdBy": "uuid",
  "createdAt": 1234567890
}

Errors:
401 - Unauthorized
500 - Server error
```

#### List Available Games
```
GET /api/games

Headers:
  Authorization: Bearer <token>

Query Parameters:
  ?status=waiting  // Optional: filter by status

Response 200:
{
  "games": [
    {
      "gameId": "uuid",
      "playerCount": 2,
      "status": "WAITING_FOR_PLAYERS",
      "createdAt": 1234567890
    }
  ]
}

Errors:
401 - Unauthorized
```

#### Get Game State
```
GET /api/games/:gameId

Headers:
  Authorization: Bearer <token>

Response 200:
{
  "gameState": GameState  // See GAME_STATE_SPEC.md
}

Errors:
401 - Unauthorized
404 - Game not found
```

## WebSocket API

### Connection

```typescript
// Client connects with authentication
const socket = io('ws://localhost:3000', {
  auth: {
    token: 'jwt_token_here'
  }
});
```

### Connection Events

#### connect
```typescript
// Emitted when connection established
socket.on('connect', () => {
  console.log('Connected with ID:', socket.id);
});
```

#### disconnect
```typescript
// Emitted when connection lost
socket.on('disconnect', (reason) => {
  console.log('Disconnected:', reason);
});
```

#### error
```typescript
// Emitted on connection error
socket.on('error', (error) => {
  console.error('Socket error:', error);
});
```

### Game Events (Client → Server)

#### JOIN_GAME
```typescript
// Join an existing game
socket.emit('JOIN_GAME', {
  gameId: string
});

// Server Response (via GAME_STATE_UPDATE or ERROR)
```

#### LEAVE_GAME
```typescript
// Leave current game
socket.emit('LEAVE_GAME', {
  gameId: string
});
```

#### PLACE_BID
```typescript
// Place a bid during bidding phase
socket.emit('PLACE_BID', {
  gameId: string,
  amount: 'PASS' | 3 | 4 | 5 | 6
});

// Server validates:
// - Player is current bidder
// - Bid is valid
// Then broadcasts GAME_STATE_UPDATE
```

#### DECLARE_TRUMP
```typescript
// Declare trump suit after winning bid
socket.emit('DECLARE_TRUMP', {
  gameId: string,
  trumpSuit: 'SPADES' | 'HEARTS' | 'DIAMONDS' | 'CLUBS'
});
```

#### FOLD_DECISION
```typescript
// Decide whether to fold or stay in (non-bidders only, after trump declared)
socket.emit('FOLD_DECISION', {
  gameId: string,
  folded: boolean  // true = fold, false = stay in
});

// Server validates:
// - Player is not the bidder
// - Player hasn't already decided
// - If Clubs turn-up, folded must be false
```

#### PLAY_CARD
```typescript
// Play a card during playing phase
socket.emit('PLAY_CARD', {
  gameId: string,
  cardId: string  // e.g., "SPADES_ACE"
});

// Server validates:
// - Player's turn
// - Player hasn't folded
// - Card in hand
// - Follows suit if required
```

#### START_NEXT_ROUND
```typescript
// Request to start next round (any player can request)
socket.emit('START_NEXT_ROUND', {
  gameId: string
});

// Only works when phase is ROUND_OVER
```

### Game Events (Server → Client)

#### GAME_STATE_UPDATE
```typescript
// Sent whenever game state changes
// All players in game receive this

socket.on('GAME_STATE_UPDATE', (data: {
  gameState: GameState,
  event: string  // What triggered the update
}) => {
  // Update local game state
});

// Triggered by:
// - Player joins/leaves
// - Bid placed
// - Trump declared
// - Card played
// - Round ends
```

#### ERROR
```typescript
// Sent when player action is invalid
socket.on('ERROR', (error: {
  code: string,
  message: string,
  context?: any
}) => {
  // Display error to user
});

// Error codes:
// - INVALID_ACTION: Action not allowed in current phase
// - NOT_YOUR_TURN: Not the current player
// - INVALID_BID: Bid is too low or already passed
// - INVALID_CARD: Card not in hand
// - MUST_FOLLOW_SUIT: Must play card of led suit
// - CANNOT_FOLD: Cannot fold (either bidder or Clubs turn-up)
// - ALREADY_FOLDED: Already made fold decision
// - PLAYER_FOLDED: Cannot play, player has folded
// - GAME_NOT_FOUND: Game doesn't exist
// - GAME_FULL: Cannot join, already 4 players
// - UNAUTHORIZED: Invalid token
```

#### PLAYER_CONNECTED
```typescript
// Notify when a player connects/reconnects
socket.on('PLAYER_CONNECTED', (data: {
  playerId: string,
  playerName: string,
  playerPosition: number
}) => {
  // Show notification
});
```

#### PLAYER_DISCONNECTED
```typescript
// Notify when a player disconnects
socket.on('PLAYER_DISCONNECTED', (data: {
  playerId: string,
  playerPosition: number
}) => {
  // Show notification
  // Note: Game state persists, player can reconnect
});
```

#### TRICK_COMPLETE
```typescript
// Emitted when a trick is complete (all 4 cards played)
// Gives clients time to animate before continuing
socket.on('TRICK_COMPLETE', (data: {
  trick: Trick,
  winnerPosition: number,
  nextLeaderPosition: number,
  delayMs: number  // Server-suggested animation delay (e.g., 2000)
}) => {
  // Show trick winner animation
  // Server will send next GAME_STATE_UPDATE after delay
});
```

#### ROUND_COMPLETE
```typescript
// Emitted when round ends, before scoring
socket.on('ROUND_COMPLETE', (data: {
  roundNumber: number,
  winningBidderPosition: number,
  bid: number,
  tricksTaken: Record<number, number>,
  scores: Record<number, number>,  // Score changes this round
  totalScores: Record<number, number>,  // Total scores after update
  bidderMadeContract: boolean
}) => {
  // Show round summary
  // Server will transition to ROUND_OVER phase
});
```

## WebSocket Room Strategy

```typescript
// Rooms structure:
// - Each game has a room: `game:${gameId}`
// - Players join room when joining game
// - Players leave room when leaving game
// - Broadcasts go to room, not individual sockets

// Server-side pseudo-code:
socket.on('JOIN_GAME', ({ gameId }) => {
  socket.join(`game:${gameId}`);
  io.to(`game:${gameId}`).emit('GAME_STATE_UPDATE', ...);
});
```

## Data Flow Examples

### Starting a Game

```
1. Client: POST /api/auth/join { playerName: "Alice" }
   Server: Returns { playerId, token }

2. Client: POST /api/games
   Server: Returns { gameId }

3. Client: socket.emit('JOIN_GAME', { gameId })
   Server: Adds player to game
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'PLAYER_JOINED' })

4. Three more players repeat step 3

5. When 4th player joins:
   Server: Transitions to DEALING phase
   Server: Deals cards
   Server: Transitions to BIDDING phase
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'ROUND_STARTED' })
```

### Bidding Sequence

```
1. Client (Player 1): socket.emit('PLACE_BID', { gameId, amount: 3 })
   Server: Validates bid
   Server: Updates game state
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'BID_PLACED' })

2. Client (Player 2): socket.emit('PLACE_BID', { gameId, amount: 'PASS' })
   Server: Updates game state
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'BID_PLACED' })

3. Client (Player 3): socket.emit('PLACE_BID', { gameId, amount: 4 })
   Server: Updates game state (now highest bid is 4)
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'BID_PLACED' })

4. Client (Player 0): socket.emit('PLACE_BID', { gameId, amount: 'PASS' })
   Server: Updates game state
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'BID_PLACED' })

5. Client (Player 1): socket.emit('PLACE_BID', { gameId, amount: 'PASS' })
   Server: Bidding complete (only Player 3 hasn't passed)
   Server: Transitions to DECLARING_TRUMP
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'BIDDING_COMPLETE' })

6. Client (Player 3): socket.emit('DECLARE_TRUMP', { gameId, trumpSuit: 'HEARTS' })
   Server: Sets trump suit
   Server: Transitions to PLAYING
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'TRUMP_DECLARED' })
```

### Playing a Trick

```
1. Client (Bidder): socket.emit('PLAY_CARD', { gameId, cardId: 'HEARTS_JACK' })
   Server: Validates card play
   Server: Removes card from hand, adds to currentTrick
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'CARD_PLAYED' })

2. Next 3 players repeat step 1

3. After 4th card:
   Server: Calculates trick winner
   Server: io.to(game).emit('TRICK_COMPLETE', { trick, winnerPosition, ... })
   Server: Waits 2 seconds
   Server: Updates state (increment tricksTaken, new currentTrick)
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'TRICK_COMPLETE' })

4. Repeat until 6 tricks played

5. After 6th trick:
   Server: Calculates scores
   Server: io.to(game).emit('ROUND_COMPLETE', { scores, ... })
   Server: Updates player scores
   Server: Checks if anyone reached 50 points
   Server: Transitions to ROUND_OVER or GAME_OVER
   Server: io.to(game).emit('GAME_STATE_UPDATE', { gameState, event: 'ROUND_COMPLETE' })
```

## Error Handling

### Invalid Actions
```typescript
// Example: Playing out of turn
Client: socket.emit('PLAY_CARD', { gameId, cardId: 'HEARTS_ACE' })
Server: Validates currentPlayerPosition !== player.position
Server: socket.emit('ERROR', {
  code: 'NOT_YOUR_TURN',
  message: 'It is not your turn to play',
  context: { currentPlayer: 2 }
})
```

### Must Follow Suit
```typescript
// Example: Player has led suit but plays different suit
Client: socket.emit('PLAY_CARD', { gameId, cardId: 'SPADES_ACE' })
Server: Validates with canPlayCard()
Server: socket.emit('ERROR', {
  code: 'MUST_FOLLOW_SUIT',
  message: 'You must follow suit',
  context: { 
    ledSuit: 'HEARTS',
    validCards: ['HEARTS_9', 'HEARTS_KING']
  }
})
```

### Network Interruption
```typescript
// Player disconnects mid-game
Server: Detects disconnect
Server: Sets player.connected = false
Server: io.to(game).emit('PLAYER_DISCONNECTED', { playerId, playerPosition })
Server: Game state persists

// Player reconnects
Client: Reconnects with same token
Client: socket.emit('JOIN_GAME', { gameId })
Server: Recognizes player by playerId in token
Server: Sets player.connected = true
Server: socket.emit('GAME_STATE_UPDATE', { gameState, event: 'RECONNECT' })
Server: io.to(game).emit('PLAYER_CONNECTED', { playerId, playerPosition })
```

## Rate Limiting (Future Enhancement)

For MVP, no rate limiting. Consider adding later:
- Max 10 actions per second per player
- Max 5 new games per hour per IP

## Security Considerations

### Token Validation
- All WebSocket events validate JWT token
- Tokens expire after 24 hours
- Player must re-authenticate after expiration

### Game State Visibility
- Players receive full game state (no hidden information after dealing)
- Card hands are visible only to owning player
- Backend never sends other players' hands to client

### Input Validation
- All player inputs validated server-side
- Client-side validation for UX only
- Zod schemas for all inputs

## TypeScript Types for API

```typescript
// Request/Response types for REST API
export interface JoinRequest {
  playerName: string;
}

export interface JoinResponse {
  playerId: string;
  playerName: string;
  token: string;
  expiresAt: number;
}

export interface CreateGameResponse {
  gameId: string;
  createdBy: string;
  createdAt: number;
}

export interface ListGamesResponse {
  games: GameSummary[];
}

export interface GameSummary {
  gameId: string;
  playerCount: number;
  status: string;
  createdAt: number;
}

// WebSocket event payloads
export interface JoinGamePayload {
  gameId: string;
}

export interface PlaceBidPayload {
  gameId: string;
  amount: 'PASS' | 2 | 3 | 4 | 5;
}

export interface DeclareTrumpPayload {
  gameId: string;
  trumpSuit: 'SPADES' | 'HEARTS' | 'DIAMONDS' | 'CLUBS';
}

export interface FoldDecisionPayload {
  gameId: string;
  folded: boolean;
}

export interface PlayCardPayload {
  gameId: string;
  cardId: string;
}

export interface GameStateUpdatePayload {
  gameState: GameState;
  event: string;
}

export interface ErrorPayload {
  code: string;
  message: string;
  context?: any;
}

export interface TrickCompletePayload {
  trick: Trick;
  winnerPosition: number;
  nextLeaderPosition: number;
  delayMs: number;
}

export interface RoundCompletePayload {
  roundNumber: number;
  winningBidderPosition: number;
  bid: number;
  tricksTaken: Record<number, number>;
  scores: Record<number, number>;
  totalScores: Record<number, number>;
  bidderMadeContract: boolean;
}
```

## Testing Endpoints (Development Only)

```
POST /api/dev/reset-game
DELETE /api/dev/games/:gameId
GET /api/dev/state

// Only available when NODE_ENV !== 'production'
```

